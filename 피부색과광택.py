# -*- coding: utf-8 -*-
"""피부색과광택.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZZc-8IicXsbE5NI2CKzVnJ9TKx8yws1O
"""

import pandas as pd

before1 = pd.read_excel('사람1before.xlsx')
after1 = pd.read_excel('사람1after.xlsx')
before2 = pd.read_excel('사람2before.xlsx')
after2 = pd.read_excel('사람2after.xlsx')
before3 = pd.read_excel('사람3before.xlsx')
after3 = pd.read_excel('사람3after.xlsx')
before4 = pd.read_excel('사람4before.xlsx')
after4 = pd.read_excel('사람4after.xlsx')

before1_l = before1.iloc[0, :]
before1_a = before1.iloc[1, :]
before1_b = before1.iloc[2, :]
print(before1_l, before1_a, before1_b)

after1_l = after1.iloc[0, :]
after1_a = after1.iloc[1, :]
after1_b = after1.iloc[2, :]
print(after1_l, after1_a, after1_b)

totalL_1 = pd.concat([before1_l, after1_l], axis=1)
totalL_1.columns = ['before', 'after']
totalL_1 = totalL_1.dropna().astype(float)
totalL_1

import seaborn as sns
import matplotlib.pyplot as plt

#before,after 값 비교
sns.barplot(data = totalL_1)
plt.show()

import scipy.stats
from scipy.stats import shapiro
from scipy.stats import levene

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totalL_1.iloc[:, 0], totalL_1.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 L값 변화

totala_1 = pd.concat([before1_a, after1_a], axis=1)
totala_1.columns = ['before', 'after']
totala_1 = totala_1.dropna().astype(float)
totala_1

#before,after 값 비교
sns.barplot(data = totala_1)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totala_1.iloc[:, 0], totala_1.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 a값 변화

totalb_1 = pd.concat([before1_b, after1_b], axis=1)
totalb_1.columns = ['before', 'after']
totalb_1 = totalL_1.dropna().astype(float)
totalb_1

#before,after 값 비교
sns.barplot(data = totalb_1)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totalb_1.iloc[:, 0], totalb_1.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 b값 변화

before2_l = before2.iloc[0, :]
before2_a = before2.iloc[1, :]
before2_b = before2.iloc[2, :]

after2_l = after2.iloc[0, :]
after2_a = after2.iloc[1, :]
after2_b = after2.iloc[2, :]

totalL_2 = pd.concat([before2_l, after2_l], axis=1)
totalL_2.columns = ['before', 'after']
totalL_2 = totalL_2.dropna()
totalL_2.drop(totalL_2.index[0], inplace = True)
totalL_2 = totalL_2.astype(float)

totalA_2 = pd.concat([before2_a, after2_a], axis=1)
totalA_2.columns = ['before', 'after']
totalA_2 = totalA_2.dropna()
totalA_2.drop(totalA_2.index[0], inplace = True)
totalA_2 = totalA_2.astype(float)

totalB_2 = pd.concat([before2_b, after2_b], axis=1)
totalB_2.columns = ['before', 'after']
totalB_2 = totalB_2.dropna()
totalB_2.drop(totalB_2.index[0], inplace = True)
totalB_2 = totalB_2.astype(float)

print(totalL_2, totalA_2, totalB_2)

sns.barplot(data = totalL_2)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totalL_2.iloc[:, 0], totalL_2.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 L값 변화

sns.barplot(data = totalA_2)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totalA_2.iloc[:, 0], totalA_2.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 a값 변화

sns.barplot(data = totalB_2)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(totalB_2.iloc[:, 0], totalB_2.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 b값 변화

dif_1 = after1 - before1
dif_1.index = ['L', 'a', 'b']
dif_1 = dif_1.dropna(axis=1)
dif_1 = dif_1.transpose()
dif_1

dif_1.dtypes

sns.barplot(data = dif_1)
plt.show()

before2 = before2.iloc[:, 1:4]
before2
after2 = after2.iloc[:, 1:4]

dif_2 = after2 - before2
dif_2

dif_2.index = ['L', 'a', 'b']
dif_2 = dif_2.dropna(axis=1)
dif_2 = dif_2.transpose()
dif_2

sns.barplot(data = dif_2)
plt.show()

# L 등분산성 고려
print(levene(dif_1.iloc[:, 0], dif_2.iloc[:, 0]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(dif_1.iloc[:, 0], dif_2.iloc[:, 0], equal_var = True)
#p-value가 유의수준보다 작으므로 변화량이 유의미함

# a 등분산성 고려
print(levene(dif_1.iloc[:, 1], dif_2.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(dif_1.iloc[:, 1], dif_2.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 변화량이 유의미함

# b 등분산성 고려
print(levene(dif_1.iloc[:, 2], dif_2.iloc[:, 2]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(dif_1.iloc[:, 2], dif_2.iloc[:, 2], equal_var = True)
#p-value가 유의수준보다 작으므로 변화량이 유의미함

#ㅣ사람간 차이
df = pd.concat([before1_l, before2_l], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 크므로 유의미하지 않음

#a 사람간 차이
df = pd.concat([before1_a, before2_a], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.
scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 크므로 유의미하지 않음

#b 사람간 차이
df = pd.concat([before1_b, before2_b], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.
scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 유의미함

# l 제품 간 차이
df = pd.concat([after1_l, after2_l], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.
scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 유의미함

# a 제품 간 차이
df = pd.concat([after1_a, after2_a], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.
scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 유의미함

# b 제품 간 차이
df = pd.concat([after1_b, after2_b], axis = 1)
df = df.dropna()
df.columns = (1, 2)
df = df.astype('float')
df

sns.barplot(data = df)
plt.show()

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.
scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 유의미함

#glossymeter사람간 차이
df = pd.concat([before3, before4], axis = 0)
df.index = ['1', '2']
df = df.transpose()
df

sns.barplot(data = df)
plt.show()

#정규성
normal1 = shapiro(df.iloc[:, 0])
normal2 = shapiro(df.iloc[:, 1])
print(normal1, normal2)
#p-value모두 0.05보다 크기 때문에 정규성에 문제가 없음

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 크므로 유의미하지 않음

#제품 간 차이
df = pd.DataFrame({1: [6.1, 4.5, 6.0], 2: [3.4, 2.9, 2.8]}, index = ['1차', '2차', '3차'])
df

sns.barplot(data = df)
plt.show()

#정규성
normal1 = shapiro(df.iloc[:, 0])
normal2 = shapiro(df.iloc[:, 1])
print(normal1, normal2)
#p-value모두 0.05보다 크기 때문에 정규성에 문제가 없음

# 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 제품 간 차이 유의미

#제품 1 변화
df = pd.concat([before3, after3], axis=0)
df.index = ['before', 'after']
df = df.transpose()
df

sns.barplot(data = df)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(df.iloc[:, 0], df.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 b값 변화

#제품 2 변화
df = pd.concat([before4, after4], axis=0)
df.index = ['before', 'after']
df = df.transpose()
df = df.fillna(2.9)
df.index = range(len(df))

# 4번째 행을 삭제하고 인덱스를 재설정
df = df.drop(3).reset_index(drop=True)
df.index = ['1차','2차','3차']
df

sns.barplot(data = df)
plt.show()

# 대응표본 t검정 수행
scipy.stats.ttest_rel(df.iloc[:, 0], df.iloc[:, 1])
#p-value가 유의수준 0.05보다 작기때문에 귀무가설을 기각, 제품을 바른 후 b값 변화

# 변화량
before3
before3 = before3.T
before3.index = [1, 2, 3]
before3

before4
before4 = before4.T
before4.index = [1, 2, 3]
before4

after3
after3 = after3.T
after3.index = [1, 2, 3]
after3

after4
after4 = after4.T
after4.index = [1, 2, 3]
after4

df1 = after3 - before3
df1

df2 = after4 - before4
df2

df = pd.concat([df1, df2], axis = 1)
df.columns = ['1', '2']
df

sns.barplot(data = df)
plt.show()

# L 등분산성 고려
print(levene(df.iloc[:, 0], df.iloc[:, 1]))
#p-value가 0.05보다 커서 등분산성이 있다고 할 수 있다.

scipy.stats.ttest_ind(df.iloc[:, 0], df.iloc[:, 1], equal_var = True)
#p-value가 유의수준보다 작으므로 제품 간 차이 유의미